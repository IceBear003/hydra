# Hydra小队 全技术细节

## **高速多端口共享缓存管理模块**

### 基本概念

SRAM参数：32块，位宽16，深度16384

端口参数：wr_data和rd_data位宽均为16，其他接口位宽均为1

半字（half word）：16bits，即2bytes

页（page）：8半字，即128bits，16bytes

物理地址（phsical address）：与SRAM交互时直接使用的地址，可以认为每个物理地址可在SRAM中访问到一个半字的信息。由于SRAM的深度为16384，故对于一个SRAM来说，物理地址为14位，又由于共有32块SRAM，故相对于外界而言，物理地址为5+14位，描述了哪一块SRAM的哪一个半字。

线性地址（linear address）：与SRAM交互时间接使用的地址，一个线性地址可生成八个物理地址，映射关系成线性。可以认为每个线性地址对应一页。由于SRAM共有2048页，对于一个SRAM来说，线性地址为11位，又由于共有32块SRAM，故相对于外界而言，线性地址有5+11位，描述了哪一块SRAM的哪一页。

### 数据包

#### 包参数

由题干可知，一个数据包长度为64~1024字节，合32~512半字/4~64页。

#### 包格式

数据包从端口写入时，由控制和数据部分组成，现拟定控制部分长16位，由9位长度、3位优先级、4位目的端口号组成。其中9位长度为数据包有多少半字（与512相对应）。

#### 存储形式

SRAM分配空间时以页为单位，即对于N字节的数据包，其占用的空间为⌈N/16⌉，即最后一页可能只有一部分有数据。同一个数据包分配的页不一定全部连续。

存入1页需要写入8半字，因此也就需要8个周期。当数据源源不断地从端口每半字地写入，每半字都在1个周期后立刻写入SRAM（此机制将在时序章节中详细说明）。

存储在SRAM里时，数据包仍然具有控制部分，但与从端口写入时略有区别。此时第一个半字并非9+3+4的形式，而是(2+)6+(5+)3的形式，其中6位数字X表示数据包占X+1页（与数据包最多64页对应），3位数字Y表示数据包的最后一页有Y+1半字（与1页有8半字对应）。可以注意到，这里的X和Y实际上就是原来的9位长度从中间拆分开直接得到。

#### 纠错策略

本模块使用传统的ECC汉明校验，每1页数据生成8位校验码。运算校验码时采用了异或树的结构，大大缩短了运算时间（从127次串行运算变为7次串并行运算）。

校验码存储在SRAM外部，每个SRAM都包含一个长度为2048的8位数字数组，分别对应SRAM中每一页的纠错信息，因此任意一页的纠错码存储位置可直接通过线性地址描述。

当1页的数据写入完毕时，校验码将会生成并存储在对应的位置。当1页的数据读出时，校验码将会被取出并参与SEC过程，可以注意到，对于1页中第1半字的数据，需要等到第8半字的数据取出才能被纠错，这会导致读数据滞后7个周期，本模块采用了预读取的策略，消除了该滞后（此机制将在时序章节中详细说明）。

#### 内存回收

为了实现内存自动申请、回收的功能，本模块使用了空闲队列，一个类FIFO(first in, first out)的数据结构，描述了SRAM中哪些页是空闲的。由此可知，每一个SRAM都绑定一个空闲队列。

空闲队列本质上是一个宽度为11，深度为256的FIFO。每一个11位的元素都是一个线性地址，指向了SRAM中空闲的一页。当新一页的数据写入SRAM时，将会直接使用从空闲队列头弹出元素的线性地址，生成物理地址完成写操作；当读出一页数据时，意味着数据原本占用的页重新回到了空闲状态，该页的地址将会被推入队尾，等待后续被弹出重新利用。这样就完成了时间复杂度为O(1)的内存分配、回收机制。

随着模块的使用，不同大小的包被频繁地写入SRAM，从SRAM读出，内存碎片化的问题难以避免（内部碎片），此时新写入的数据包的页几乎完全破碎，存储于不相邻的空闲页中。对应空闲队列的深度需要高大2048（SRAM的每一页都有可能空闲），占用较大（每块SRAM的空闲队列为2048*11bits=2.8KB，所有SRAM合起来90KB）。为了避免内存碎片化的问题，Hydra模块引入了位图与一个尾计数器辅助管理内存。

位图是一个宽度为1，长度为2048的数组，每一个元素都对应了一页的状态，若值为0，则表示当前页空闲，且与前一页“吸附”；若值为1，则表示当前页空闲，未与前一页“吸附”或被占用。接下来，将会详细描述去碎片化过程。

当页从占用状态回归空闲状态：

​	如果前页为吸附状态（0）或队尾地址为当前页的前页地址，则其被标记为“吸附”（0），无需被推入队尾，同时尾计数器+1；

​	如果前页为占用状态（1）且队尾地址不为当前页的前页地址，则检测尾计数器的大小K：

​		如果K小于等于3，且当前页的后(4-K)页不是均为“吸附”态，则将尾地址改为“吸附”态，当前页直接覆盖原尾地址（而不是推入）。

​		如果为其他情况，则直接将当前页地址推入空闲队列，尾计数器清零。

当为写入的新数据请求1页：

​	取出空闲队列头地址，如果头地址的下页的状态为“吸附”态，则头地址覆写为下页的地址，否则弹出原头地址。

用直观的话表述上面的过程，实际上就是保证了可以被访问并分配的空闲页都是成一串一串的，且一串的大小至少为4。如果腾出的页并未处于一连串的状态，或一连串的长度小于4，则暂时不让它们不加入队列中待命，将它们“悬挂”起来，等待相邻的前若干页被释放后，跟随其进入可分配空间。



### 端口



### 时序细节



### 模块



### 亮点



### 缺点



